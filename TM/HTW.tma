#===============================================================
# ER-2 Flights, April 2020; Palmdale, CA, DCOTSS Mission
# Flight HTW.tma.
#===============================================================

#---------------------------------------------------------------
# Partition 1: Main Line Code
#---------------------------------------------------------------

### Need to verify switches before we use them
# Switches - 1100: Algo., 1111: No Algo. (Use runfile.1100 for flight)
# For Flight, 2 Switches in the Off (Zero) Position.
# If either switch in On (1, raised), most algo processing is suspended.
# If both switches are On (1, raised) Shutdown begins immediately.

%{
  #include "msg.h"
  #include "SWData.h"
%}

# INITIALIZE
State Init {
       > Telemetry Start
  +1   > Fail Light Off
  +1   > AI Double Convert Row Zero
  +10  Validate Throttle_Valve_Init;
  +15  Validate Standby;
}

# WAIT 
State Standby {
        depending on (OFF_GROUND) { Validate Record; }
        depending on (IN_AIR) { Validate Record; }
        depending on (AI_Fail)   { Validate Shutdown; }
}

# RECORD  
State Record {
        depending on (ON_GROUND) { Validate Shutdown; }
        # depending on (h2o2failA) { Validate Shutdown; }
        depending on (AI_Fail)   { Validate Shutdown; }
        "In Record";
}

# SHUTDOWN
State Shutdown {
      Hold until valid (Laser_Ops_Is_Shutdown) or 20;
 +5   > Fail Light On
      > quit
}

#---------------------------------------------------------------
# Partition 2: Altitude
#---------------------------------------------------------------
Partition

# This partition converts pressure (altitude) into states 
# (ON_GROUND, OFF_GROUND, IN_AIR). \
# The threshold pressures each have two values - one for 
# the flight up and the other for the flight down.
# This provides hysteresis and prevents bouncing.  
# We are effectively using two switches: 
# 	ON_GROUND and IN_AIR (BELOW CLOUDS = ABOVE CLOUDS)
# REF: 650 torr ~5000 ft

%{ /* Altitude definitions */
    double P_ground_up = 525.;
    double P_ground_dn = 575.;
    double P_clouds_up = 280.;
    double P_clouds_dn = 370.;
    int using_swp = 0;
%}

State ON_GROUND {
  { using_swp = 0; }
  { if (using_swp || (DACS_P > 0 && DACS_P < P_ground_up))
      Validate OFF_GROUND;
  }
}

State OFF_GROUND {
  { if ((using_swp == 2) || (!using_swp && DACS_P > 0 && DACS_P < P_clouds_up)) {
      Validate IN_AIR;
    } else if ((using_swp == 4) || (!using_swp && DACS_P > P_ground_dn)) {
      Validate ON_GROUND;
    }
  }
}

State IN_AIR {
  { if ( (using_swp == 3) || (!using_swp && DACS_P > P_clouds_dn))
      Validate OFF_GROUND;
  }
}

#---------------------------------------------------------------
# Partition 3: HTW
#---------------------------------------------------------------
Partition

State HTW_Init {
     Depending on (Shutdown) { Validate HTW_Shutdown; }
     Depending on (Shutdown) { Validate HTW_Shutdown; }
     Depending on (IN_AIR) { Validate HTW_Startup; }
     Depending on (OFF_GROUND) { Validate HTW_Startup; }
}

State HTW_Startup {
     Depending on (Shutdown) { Validate HTW_Shutdown; }
     Depending on (Shutdown) { Validate HTW_Shutdown; }
     Depending on (ON_GROUND) { Validate HTW_Shutdown; }
  #  Validate Nano_Nano800;
}

State HTW_Shutdown {}

#---------------------------------------------------------------
# Partition 4: Laser Operations
#---------------------------------------------------------------
Partition

%{
  int Laser_Ops_Ready_To_Calibrate;
%}

State Laser_Ops_Init {
 # +1 > Pressure Reg Off
      > Laser TEC Live SetPoints Enable
      Depending on (Shutdown) { Validate Laser_Ops_Shutdown; }
      Depending on (Record) { Validate Laser_Ops_Start; }
}

State Laser_Ops_Start {
      Depending on (Shutdown) { Validate Laser_Ops_Shutdown; }
   +5 Hold until valid (Pump_Watch);
   +1 > Laser TEC Setpoint 7.8 C
   +1 > Laser TEC Enable
  +30 Validate Laser_Ops_Sample;
}

State Laser_Ops_Sample {
       Depending on (Shutdown) { Validate Laser_Ops_Shutdown; }
       { if (!Pump_On_Off) Validate Laser_Ops_Fill_To_Ambient; }
    +1 Validate QCL_SelectRingandRun;
   +30 Validate QCL_SelectICOSandRun;
}

State Laser_Ops_Calibrate {
     Depending on (Shutdown) { Validate Laser_Ops_Shutdown; }
     { if (!Pump_On_Off) Validate Laser_Ops_Fill_To_Ambient; }
}

State Laser_Ops_End_Calibrate {
     Depending on (Shutdown) { Validate Laser_Ops_Shutdown; }

   +20 Validate QCL_NC_1;
    +1 Hold until valid (QCL_Watch);
   +10 Validate QCL_Stop;
       Hold Until Valid (QCL_Idle);
       { Laser_Ops_Ready_To_Calibrate = 3;
         Validate Laser_Ops_Sample;
       }
}

State Laser_Ops_Fill_to_Ambient {
    { Laser_Ops_Ready_To_Calibrate = 0; }
    { if (Pump_On_Off) Validate Laser_Ops_Sample; }
    Depending on (Shutdown) { Validate Laser_Ops_Shutdown; }
}

State Laser_Ops_Shutdown {
 #   > Pressure Reg Off
  +1 Hold until valid (QCL_Is_Shutdown);
     Validate Laser_Ops_Is_Shutdown;
}

State Laser_Ops_Is_Shutdown {}

#---------------------------------------------------------------
# Partition 5: Laser Control JPL 53
#---------------------------------------------------------------
Partition

%{
  int num_QCL_recovers = 0;
  #define LOW_CURRENT 0.02
  #define QCL_TEMP_LIMIT 20
  #define QCL_TEMP_PREC 1.0
  #define QCL_TEMP_OK(x,y) \
  (x < QCL_TEMP_LIMIT && x > y-QCL_TEMP_PREC && x < y+QCL_TEMP_PREC)
  #define LPV_TEMP_OK(x,y) (x < (y+1))
%}
# Mini Starting and Stopping

State QCL_Init {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
  +1  > SSP Stop
  +1  Validate QCLI_Stop;
      Hold until valid (QCLI_Idle);
      Validate QCL_Idle;
}

State QCL_Idle {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
    Validate QCLI_Idle;
}

State QCL_Start {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
    Hold until ( SSP_Status == SSP_STATUS_READY )
    or 2 else {
      nl_error( 2, "SSP Not Ready in QCL_Start" );
      Validate QCL_SSP_Recover;
    }
    Hold until ( QCL_TEMP_OK(convert(LTE_T),convert(LTE_Set_T)) ) or 20
    else Validate QCL_Out_TSpec;
    Hold until valid (QCLI_Idle) or 2
    else Validate QCLI_Stop;
    Hold until valid (QCLI_Idle);
 +1 > SSP Start
    Hold until ( SSP_Status == SSP_STATUS_ARMED )
    or 20 else {
      nl_error( 2, "Not Armed in QCL_Start" );
      Validate QCL_SSP_Recover;
    }
    Validate QCLI_Run;
    Hold until (SSP_Status == SSP_STATUS_TRIG &&
                convert(Las_I) > LOW_CURRENT) or 20
    else Validate QCL_SSP_Recover;
    { num_QCL_recovers = 0; }
    Validate QCL_Watch;
}

# QCL_NC_1: stop SSP, set NCoadd to 1 and restart SSP
# without shutting down QCLI
State QCL_NC_1 {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
   +1 > SSP Stop
      Hold until (SSP_Status == SSP_STATUS_READY) or 2 else {
        nl_error( 2, "SSP Not Ready in QCL_NC_1" );
        Validate QCL_SSP_Recover;
      }
   +1 > SSP Set NCoadd 1
      > SSP Start
      Hold until (SSP_Status == SSP_STATUS_ARMED ||
                  SSP_Status == SSP_STATUS_TRIG) or 20 else {
        nl_error(2, "Not starting in QCL_NC_1");
        Validate QCL_SSP_Recover;
      }
   +1 Validate QCL_Watch;
}

State QCL_Watch NoLog {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
    { if ( SSP_Status == SSP_STATUS_READY ) {
        nl_error( 2, "SSP Went Ready Spontaneously" );
        Validate QCL_SSP_Recover;
      }
    }
    hold until ( SSP_Status != SSP_STATUS_TRIG ||
         !QCL_TEMP_OK(convert(LTE_T),convert(LTE_Set_T)) ||
         convert(Las_I) <= LOW_CURRENT );
    hold until ( SSP_Status == SSP_STATUS_TRIG &&
         QCL_TEMP_OK(convert(LTE_T),convert(LTE_Set_T)) &&
         convert(Las_I) >= LOW_CURRENT) or 2
    else Validate QCL_Watch_Recover;
    Validate QCL_Watch;
}

State QCL_Watch_Recover NoLog {
  { if (!QCL_TEMP_OK(convert(LTE_T),convert(LTE_Set_T)))
      Validate QCL_Out_TSpec;
    else if (convert(Las_I) <= LOW_CURRENT)
      Validate QCL_Out_Spec;
    else if (SSP_Status != SSP_STATUS_TRIG)
      Validate QCL_SSP_Recover;
    else Validate QCL_Watch;
  }
}

State QCL_SSP_Recover NoLog {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
    > SSP Stop
    { if ( ++num_QCL_recovers > 20 ) {
        nl_error( 2, "Exceeded num_QCL_recovers. Trying reset" );
        num_QCL_recovers = 0;
        Validate QCLI_Stop_Reset;
      }
    }
    Hold until ( SSP_Status == SSP_STATUS_READY ) or 10
    else Validate QCL_SSP_Not_Talking;
 +2 Validate QCLI_Stop;
    Hold until valid (QCLI_Idle);
    Validate QCL_Start;
}

State QCL_SSP_Not_Talking {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
    > SSP Stop
    { if ( ++num_QCL_recovers > 20 ) Validate QCL_Fail; }
    Hold until ( SSP_Status == SSP_STATUS_READY ) or 10
    else Validate QCL_SSP_Not_Talking;
    Validate QCL_SSP_Recover;
}

State QCL_Fail {
    > Log Laser Has Failed
    > SSP Stop
    Validate QCLI_Stop;
    > Laser TEC Disable
    depending on (Shutdown) { Validate QCL_Is_Shutdown; }
}

State QCL_Shutdown {
    > SSP Stop
 +1 Validate QCLI_Stop;
    Hold until valid (QCLI_Idle) or 20;
    > Log Laser Has Shutdown
    > Laser TEC Disable
    Validate QCL_Is_Shutdown;
}

State QCL_Is_Shutdown {}

State QCL_Out_Spec {
    Validate QCLI_Stop;
    Hold until Valid (QCLI_Idle);
    Validate QCL_Start;
}

State QCL_Out_TSpec {
    Validate QCLI_Stop;
 +1 > Laser TEC Enable
    Hold until valid (QCLI_Idle);
    Hold until ( QCL_TEMP_OK(convert(LTE_T),convert(LTE_Set_T)) &&
                 LPV_TEMP_OK(convert(LPV_T),convert(LPV_Set_T)) );
 +10 Validate QCL_Start;
}

State QCL_Stop {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
    > SSP Stop
 +1 Validate QCLI_Stop;
    Hold until valid (QCLI_Idle);
    Validate QCL_Idle;
}

#Running Waveforms

State QCL_SelectICOSandRun {
      Depending on (Shutdown) { Validate QCL_Shutdown; }
      > SSP Stop
      Hold until ( SSP_Status == SSP_STATUS_READY ) or 5
      else { nl_error( 2, "Not Ready in QCL_SelectICOSandRun" ); }
      Hold until valid (QCLI_Idle) or 2
      else Validate QCLI_Stop;
      Hold until valid (QCLI_Idle);
   +1 > Laser TEC Setpoint 7.8 C
   +1 > Laser TEC Enable
      Hold until ( QCL_TEMP_OK(convert(LTE_T),convert(LTE_Set_T)) );
  +10 > Select QCLI Waveform JPL53_400Hz
   +3 Validate QCL_Start;
}

State QCL_SelectRingandRun {
      Depending on (Shutdown) { Validate QCL_Shutdown; }
      > SSP Stop
      Hold until ( SSP_Status == SSP_STATUS_READY ) or 5
      else { nl_error( 2, "Not Ready in QCL_SelectRingandRun" ); }
      Hold until valid (QCLI_Idle) or 2
      else Validate QCLI_Stop;
      Hold until valid (QCLI_Idle);
   +1 > Laser TEC Setpoint 7.8 C
   +1 > Laser TEC Enable
      Hold until ( QCL_TEMP_OK(convert(LTE_T),convert(LTE_Set_T)) );
  +10 > Select QCLI Waveform RingRamp
   +1 > SSP Set NSample 3500
   +2 Validate QCL_Start;
}

#---------------------------------------------------------------
# Partition 6: QCLI Control
#---------------------------------------------------------------
Partition

%{
  int num_QCLI_recovers = 0;
%}

State QCLI_Idle {}

State QCLI_Run {
    Hold until ( (QCLI_s & 0x3938) == 0 ) or 2
    else > QCLI clear errors
    Hold until ( (QCLI_s & 0x3938) == 0 ) or 2
    else Validate QCLI_Start_Reset;
    > QCLI Run
    { num_QCLI_recovers = 0;
      Validate QCLI_Running;
    }
}

State QCLI_Running {
}

State QCLI_Start_Reset {
    { if ( ++num_QCLI_recovers > 20 ) {
        nl_error( 2,"Exceeded num_QCLI_recovers in QCLI_Start_Reset" );
        Validate QCLI_Fail;
      }
    }
    > Command QCLI_Reset On
 +1 > Command QCLI_Reset Off
    Validate QCLI_Run;
}

State QCLI_Stop {
      > QCLI Stop
      Hold until ( (QCLI_s & 0x3938) == 0 ) or 2
      else > QCLI clear errors
      Hold until ( (QCLI_s & 0x3938) == 0 ) or 2
      else Validate QCLI_Stop_Reset;
      Validate QCLI_Idle;
}

State QCLI_Stop_Reset {
    { if ( ++num_QCLI_recovers > 20 ) {
        nl_error( 2,"Exceeded num_QCLI_recovers in QCLI_Stop_Reset" );
        Validate QCLI_Fail;
      }
    }
    > Command QCLI_Reset On
 +1 > Command QCLI_Reset Off
    Hold until ( (QCLI_s & 0x3938) == 0 ) or 2
    else > QCLI clear errors
    Hold until ( (QCLI_s & 0x3938) == 0 ) or 2
    else Validate QCLI_Stop_Reset;
    { num_QCLI_recovers = 0;
      ci_sendfcmd( 0, "Select QCLI Waveform Number %d\n", QCLI_Wave );
      Validate QCLI_Idle;
    }
}

State QCLI_Fail {
    { nl_error( 2, "QCLI Not Responding" ); }
 +2:00 Validate QCLI_Stop_Reset;
}

State QCLI_Shutdown {}

#---------------------------------------------------------------
# Partition 7: Pumpkin Troll
#---------------------------------------------------------------
Partition

State Pump_Init {}
State Pump_Start {}
State Pump_Watch {}
State Pump_Shutdown {}

#---------------------------------------------------------------
# Partition 8: Gas Deck Control
#---------------------------------------------------------------
Partition

State GasDeck_Init {
#+1 > Command Gas_Flw_Open Off
#   > Command Gas_Flw_Closed Off
#   > Command Bub_Gas_Flw_Open Off
#   > Command Bub_Gas_Flw_Closed Off
#   > Command Gas_Vlv_D Off
#   > Command Bub_Gas_Vlv_D Off
#   > Command Bub_Vlv_Flw_D Off
 +5 Validate GasDeck_Idle;
}

State GasDeck_Idle {}


#---------------------------------------------------------------
# Partition 9: Realtime File Input
#---------------------------------------------------------------
Partition

State ReadFile_idle {}

State ReadFile "HTW.tmas" {
  +5 Validate ReadFile_idle;
}

#---------------------------------------------------------------
# Partition 10: ReadFile Conditions
#---------------------------------------------------------------
# Summary:
#   RFCond_Idle: Nothing
#   RFCond_TimeWarp: Wait for Time Warp
#---------------------------------------------------------------
Partition

State RFCond_Idle {}

State RFCond_TimeWarp {
  Hold until ( SW_St == SWS_TIMEWARP );
  Resume ReadFile;
  Validate RFCond_Idle;
}

#---------------------------------------------------------------
# Partition 11: Analog Input Monitoring
#---------------------------------------------------------------
Partition

%{
  AI_T30K Last_PC__T = 0;
  static int PC__T_static_count = 0;
  static int PC__T_delta_count = 0;
  static int AI_Reset_count = 0;
  static int AI_Reset_limit = 0;
%}
State AI_Watch {
    { if ( PC__T == Last_PC__T ) {
	if ( ++PC__T_static_count >= 5 ) {
	  msg(2, "PC__T has not changed in 5 seconds");
	  PC__T_delta_count = 0;
	  Validate AI_Reset;
	}
      } else {
	Last_PC__T = PC__T;
	PC__T_static_count = 0;
	if ( ++PC__T_delta_count > 5 ) {
	  PC__T_delta_count = 0;
	  AI_Reset_count = 0;
	}
      }
    }
}

State AI_Reset {
      > AI Reset
  +1  > AI Double Convert Row Zero
      { if ( AI_Reset_limit > 0 &&
	     ++AI_Reset_count >= AI_Reset_limit ) {
	  msg(2,"AI Max Reset Count Reached");
	  Validate AI_Fail;
	}
      }
      Hold until ( PC__T != Last_PC__T ) OR 5
      else Validate AI_Reset;
      Validate AI_Watch;
}

State AI_Fail {}

#--------------------------------------------------------------
# Partition 12: Lab Calibration
#--------------------------------------------------------------
Partition

State Calibrate_Init {}

State Calibrate_Start {}

State Calibrate_Stop {}

State Calibrate_Idle {}

