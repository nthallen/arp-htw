#===============================================================
# ER-2 Flights, April 2020; Palmdale, CA, DCOTSS Mission
# Flight HTW.tma.
#===============================================================

#---------------------------------------------------------------
# Partition 1: Main Line Code
#---------------------------------------------------------------

### Need to verify switches before we use them
# Switches - 1100: Algo., 1111: No Algo. (Use runfile.1100 for flight)
# For Flight, 2 Switches in the Off (Zero) Position.
# If either switch in On (1, raised), most algo processing is suspended.
# If both switches are On (1, raised) Shutdown begins immediately.

%{
  #include "msg.h"
  #include "SWData.h"
%}

# INITIALIZE
State Init {
       > Telemetry Start
  +1   > Fail Light Off
  +1   > AI Double Convert Row Zero
  +10  Validate Throttle_Valve_Init;
  +15  Validate Standby;
}

# WAIT 
State Standby {
        depending on (OFF_GROUND) { Validate Record; }
        depending on (IN_AIR) { Validate Record; }
        depending on (AI_Fail) { Validate Shutdown; }
}

# RECORD  
State Record {
        depending on (ON_GROUND) { Validate Shutdown; }
        depending on (AI_Fail)   { Validate Shutdown; }
        "In Record";
}

# SHUTDOWN
State Shutdown {
      Hold until valid (Laser_Ops_Is_Shutdown) or 20;
 +5   > Fail Light On
      > quit
}

#---------------------------------------------------------------
# Partition 2: Altitude
#---------------------------------------------------------------
Partition

# This partition converts pressure (altitude) into states 
# (ON_GROUND, OFF_GROUND, IN_AIR). \
# The threshold pressures each have two values - one for 
# the flight up and the other for the flight down.
# This provides hysteresis and prevents bouncing.  
# We are effectively using two switches: 
# 	ON_GROUND and IN_AIR (BELOW CLOUDS = ABOVE CLOUDS)
# REF: 650 torr ~5000 ft
# Palmdale, CA is at elevation 2657'
# Salina, KS is at elevation 1227'

%{ /* Altitude definitions */
    double P_ground_up = 525.;
    double P_ground_dn = 575.;
    double P_clouds_up = 280.;
    double P_clouds_dn = 370.;
    int using_swp = 0;
%}

State ON_GROUND {
  { using_swp = 0; }
  { if (using_swp || (DACS_P > 0 && DACS_P < P_ground_up))
      Validate OFF_GROUND;
  }
}

State OFF_GROUND {
  { if ((using_swp == 2) || (!using_swp && DACS_P > 0 && DACS_P < P_clouds_up)) {
      Validate IN_AIR;
    } else if ((using_swp == 4) || (!using_swp && DACS_P > P_ground_dn)) {
      Validate ON_GROUND;
    }
  }
}

State IN_AIR {
  { if ( (using_swp == 3) || (!using_swp && DACS_P > P_clouds_dn))
      Validate OFF_GROUND;
  }
}

#---------------------------------------------------------------
# Partition 4: Laser Operations
#---------------------------------------------------------------
Partition

%{
  int Laser_Ops_Ready_To_Calibrate;
%}

State Laser_Ops_Init {
 # +1 > Pressure Reg Off
      > Laser TEC Live SetPoints Enable
      Depending on (Shutdown) { Validate Laser_Ops_Shutdown; }
      Depending on (Record) { Validate Laser_Ops_Start; }
}

State Laser_Ops_Start {
      Depending on (Shutdown) { Validate Laser_Ops_Shutdown; }
   +5 Hold until valid (Pump_Watch);
   +1 > Laser TEC Setpoint 7.8 C
   +1 > Laser TEC Enable
  +30 Validate Laser_Ops_Sample;
}

State Laser_Ops_Sample {
       Depending on (Shutdown) { Validate Laser_Ops_Shutdown; }
#      { if (!Pump_On) Validate Laser_Ops_Fill_To_Ambient; }
    +1 Validate QCL_SelectRingandRun;
   +30 Validate QCL_SelectICOSandRun;
}

# State Laser_Ops_Calibrate {
#      Depending on (Shutdown) { Validate Laser_Ops_Shutdown; }
#      { if (!Pump_On) Validate Laser_Ops_Fill_To_Ambient; }
# }

State Laser_Ops_Shutdown {
 #   > Pressure Reg Off
  +1 Hold until valid (QCL_Is_Shutdown);
     Validate Laser_Ops_Is_Shutdown;
}

State Laser_Ops_Is_Shutdown {}

#---------------------------------------------------------------
# Partition 5: Laser Control JPL 53
#---------------------------------------------------------------
Partition

%{
  int num_QCL_recovers = 0;
  #define LOW_CURRENT 0.02
  #define QCL_TEMP_LIMIT 20
  #define QCL_TEMP_PREC 1.0
  #define QCL_TEMP_OK(x,y) \
  (x < QCL_TEMP_LIMIT && x > y-QCL_TEMP_PREC && x < y+QCL_TEMP_PREC)
  #define LPV_TEMP_OK(x,y) (x < (y+1))
%}
# Mini Starting and Stopping

State QCL_Init {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
  +1  > SSP Stop
  +1  Validate QCLI_Stop;
      Hold until valid (QCLI_Idle);
      Validate QCL_Idle;
}

State QCL_Idle {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
    Validate QCLI_Idle;
}

State QCL_Start {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
    Hold until ( SSP_Status == SSP_STATUS_READY )
    or 2 else {
      nl_error( 2, "SSP Not Ready in QCL_Start" );
      Validate QCL_SSP_Recover;
    }
    Hold until ( QCL_TEMP_OK(convert(LTE_T),convert(LTE_Set_T)) ) or 20
    else Validate QCL_Out_TSpec;
    Hold until valid (QCLI_Idle) or 2
    else Validate QCLI_Stop;
    Hold until valid (QCLI_Idle);
 +1 > SSP Start
    Hold until ( SSP_Status == SSP_STATUS_ARMED )
    or 20 else {
      nl_error( 2, "Not Armed in QCL_Start" );
      Validate QCL_SSP_Recover;
    }
    Validate QCLI_Run;
    Hold until (SSP_Status == SSP_STATUS_TRIG &&
                convert(Las_I) > LOW_CURRENT) or 20
    else Validate QCL_SSP_Recover;
    { num_QCL_recovers = 0; }
    Validate QCL_Watch;
}

# QCL_NC_1: stop SSP, set NCoadd to 1 and restart SSP
# without shutting down QCLI
State QCL_NC_1 {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
   +1 > SSP Stop
      Hold until (SSP_Status == SSP_STATUS_READY) or 2 else {
        nl_error( 2, "SSP Not Ready in QCL_NC_1" );
        Validate QCL_SSP_Recover;
      }
   +1 > SSP Set NCoadd 1
      > SSP Start
      Hold until (SSP_Status == SSP_STATUS_ARMED ||
                  SSP_Status == SSP_STATUS_TRIG) or 20 else {
        nl_error(2, "Not starting in QCL_NC_1");
        Validate QCL_SSP_Recover;
      }
   +1 Validate QCL_Watch;
}

State QCL_Watch NoLog {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
    { if ( SSP_Status == SSP_STATUS_READY ) {
        nl_error( 2, "SSP Went Ready Spontaneously" );
        Validate QCL_SSP_Recover;
      }
    }
    hold until ( SSP_Status != SSP_STATUS_TRIG ||
         !QCL_TEMP_OK(convert(LTE_T),convert(LTE_Set_T)) ||
         convert(Las_I) <= LOW_CURRENT );
    hold until ( SSP_Status == SSP_STATUS_TRIG &&
         QCL_TEMP_OK(convert(LTE_T),convert(LTE_Set_T)) &&
         convert(Las_I) >= LOW_CURRENT) or 2
    else Validate QCL_Watch_Recover;
    Validate QCL_Watch;
}

State QCL_Watch_Recover NoLog {
  { if (!QCL_TEMP_OK(convert(LTE_T),convert(LTE_Set_T)))
      Validate QCL_Out_TSpec;
    else if (convert(Las_I) <= LOW_CURRENT)
      Validate QCL_Out_Spec;
    else if (SSP_Status != SSP_STATUS_TRIG)
      Validate QCL_SSP_Recover;
    else Validate QCL_Watch;
  }
}

State QCL_SSP_Recover NoLog {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
    > SSP Stop
    { if ( ++num_QCL_recovers > 20 ) {
        nl_error( 2, "Exceeded num_QCL_recovers. Trying reset" );
        num_QCL_recovers = 0;
        Validate QCLI_Stop_Reset;
      }
    }
    Hold until ( SSP_Status == SSP_STATUS_READY ) or 10
    else Validate QCL_SSP_Not_Talking;
 +2 Validate QCLI_Stop;
    Hold until valid (QCLI_Idle);
    Validate QCL_Start;
}

State QCL_SSP_Not_Talking {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
    > SSP Stop
    { if ( ++num_QCL_recovers > 20 ) Validate QCL_Fail; }
    Hold until ( SSP_Status == SSP_STATUS_READY ) or 10
    else Validate QCL_SSP_Not_Talking;
    Validate QCL_SSP_Recover;
}

State QCL_Fail {
    > Log Laser Has Failed
    > SSP Stop
    Validate QCLI_Stop;
    > Laser TEC Disable
    depending on (Shutdown) { Validate QCL_Is_Shutdown; }
}

State QCL_Shutdown {
    > SSP Stop
 +1 Validate QCLI_Stop;
    Hold until valid (QCLI_Idle) or 20;
    > Log Laser Has Shutdown
    > Laser TEC Disable
    Validate QCL_Is_Shutdown;
}

State QCL_Is_Shutdown {}

State QCL_Out_Spec {
    Validate QCLI_Stop;
    Hold until Valid (QCLI_Idle);
    Validate QCL_Start;
}

State QCL_Out_TSpec {
    Validate QCLI_Stop;
 +1 > Laser TEC Enable
    Hold until valid (QCLI_Idle);
    Hold until ( QCL_TEMP_OK(convert(LTE_T),convert(LTE_Set_T)) &&
                 LPV_TEMP_OK(convert(LPV_T),convert(LPV_Set_T)) );
 +10 Validate QCL_Start;
}

State QCL_Stop {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
    > SSP Stop
 +1 Validate QCLI_Stop;
    Hold until valid (QCLI_Idle);
    Validate QCL_Idle;
}

#Running Waveforms

State QCL_SelectICOSandRun {
      Depending on (Shutdown) { Validate QCL_Shutdown; }
      > SSP Stop
      Hold until ( SSP_Status == SSP_STATUS_READY ) or 5
      else { nl_error( 2, "Not Ready in QCL_SelectICOSandRun" ); }
      Hold until valid (QCLI_Idle) or 2
      else Validate QCLI_Stop;
      Hold until valid (QCLI_Idle);
   +1 > Laser TEC Setpoint 7.6 C
   +1 > Laser TEC Enable
      Hold until ( QCL_TEMP_OK(convert(LTE_T),convert(LTE_Set_T)) );
  +10 > Select QCLI Waveform JPL53_400Hz
   +3 Validate QCL_Start;
}

State QCL_SelectRingandRun {
      Depending on (Shutdown) { Validate QCL_Shutdown; }
      > SSP Stop
      Hold until ( SSP_Status == SSP_STATUS_READY ) or 5
      else { nl_error( 2, "Not Ready in QCL_SelectRingandRun" ); }
      Hold until valid (QCLI_Idle) or 2
      else Validate QCLI_Stop;
      Hold until valid (QCLI_Idle);
   +1 > Laser TEC Setpoint 7.8 C
   +1 > Laser TEC Enable
      Hold until ( QCL_TEMP_OK(convert(LTE_T),convert(LTE_Set_T)) );
  +10 > Select QCLI Waveform RingRamp
#  +1 > SSP Set NSample 3500
   +2 Validate QCL_Start;
}

#---------------------------------------------------------------
# Partition 6: QCLI Control
#---------------------------------------------------------------
Partition

%{
  int num_QCLI_recovers = 0;
%}

State QCLI_Idle {}

State QCLI_Run {
    Hold until ( (QCLI_s & 0x3938) == 0 ) or 2
    else > QCLI clear errors
    Hold until ( (QCLI_s & 0x3938) == 0 ) or 2
    else Validate QCLI_Start_Reset;
    > QCLI Run
    { num_QCLI_recovers = 0;
      Validate QCLI_Running;
    }
}

State QCLI_Running {
}

State QCLI_Start_Reset {
    { if ( ++num_QCLI_recovers > 20 ) {
        nl_error( 2,"Exceeded num_QCLI_recovers in QCLI_Start_Reset" );
        Validate QCLI_Fail;
      }
    }
    > Command QCLI_Reset On
 +1 > Command QCLI_Reset Off
    Validate QCLI_Run;
}

State QCLI_Stop {
      > QCLI Stop
      Hold until ( (QCLI_s & 0x3938) == 0 ) or 2
      else > QCLI clear errors
      Hold until ( (QCLI_s & 0x3938) == 0 ) or 2
      else Validate QCLI_Stop_Reset;
      Validate QCLI_Idle;
}

State QCLI_Stop_Reset {
    { if ( ++num_QCLI_recovers > 20 ) {
        nl_error( 2,"Exceeded num_QCLI_recovers in QCLI_Stop_Reset" );
        Validate QCLI_Fail;
      }
    }
    > Command QCLI_Reset On
 +1 > Command QCLI_Reset Off
    Hold until ( (QCLI_s & 0x3938) == 0 ) or 2
    else > QCLI clear errors
    Hold until ( (QCLI_s & 0x3938) == 0 ) or 2
    else Validate QCLI_Stop_Reset;
    { num_QCLI_recovers = 0;
      ci_sendfcmd( 0, "Select QCLI Waveform Number %d\n", QCLI_Wave );
      Validate QCLI_Idle;
    }
}

State QCLI_Fail {
    { nl_error( 2, "QCLI Not Responding" ); }
 +2:00 Validate QCLI_Stop_Reset;
}

State QCLI_Shutdown {}

#---------------------------------------------------------------
# Partition 7: Pumpkin Troll
# Needs to be written!
#---------------------------------------------------------------
Partition

State Pump_Init {
  +10 Validate Pump_Watch;
}

State Pump_Start {}
State Pump_Watch {}
State Pump_Shutdown {}

#---------------------------------------------------------------
# Partition 8: Gas Deck Control
# Allows control of cell pressure from gas flow based on PV PI
# Watches for low pressure in main bottle and turns of flows
# Watches for low pressure in low pressure lines and turns off flows
# Fills cell to 1 atm. pressure. 
#---------------------------------------------------------------
Partition

%{
  double GP_sum;
  /* double GP_diff */
  /* double GP_set */

 #define US_CAST(x) ((unsigned short)(x))
 #define MAX_FLOW 50000
 #include <math.h>
%}

State GasDeck_Init {
  +1 > Set GasDeck Pressure Gain Gp 8.0
  +1 > Set GasDeck Pressure Gain Gi 40.0
  +1 > Set GasDeck Pressure SetPoint 40.0
  +1 Validate GasDeck_Close;
}

State GasDeck_Close {
     > Air Flow SetPoint 0 sccm
     > Bubbler Flow SetPoint 0 sccm
  +1 > Command Gas_Vlv_D Off
  +1 > Command Bub_In_Vlv_D Off
  +1 > Command Bub_Out_Vlv_D Off
  +1 Validate GasDeck_Idle;
}

State GasDeck_Idle {}

State GasDeck_PI_Init {
  { GP_sum = 0; }
    > Command Gas_Vlv_D On
  +1 Validate GasDeck_PI;
}

State GasDeck_PI NoLog {
#  depending on (ON_GROUND) { Validate GasDeck_Close; }
  { if ( convert(GasHP) < 100 || convert(GasLP) < 10  || convert(BubLP) < 10 ) Validate GasDeck_Low_Pressure; }
  { double P, Gp, Gi, P_diff, P_set, dstep;
    unsigned short ustep;
    P = convert(CellP);
    P_set = convert(GD_SetP);
    Gp = convert(GD_Gp);
    Gi = convert(GD_Gi);
    P_diff = P_set - P;
    GP_sum += P_diff * Gi;
    if ( GP_sum > MAX_FLOW )
      GP_sum = MAX_FLOW;
    else if ( P_sum < -MAX_FLOW )
      GP_sum = -MAX_FLOW/Gi;

    dstep = P_diff * Gp + GP_sum;
    if (dstep < 0) dstep = 0;
    else if (dstep > MAX_FLOW) dstep = MAX_FLOW;
    ustep = US_CAST(dstep);
    ci_sendfcmd(2, "Air Flow SetPoint %u sccm\n", ustep);
  }

 "Regulating";
 # Probably need to add a Hold Until statement to see that the actual flow matches the setpoint
 # otherwise put up some error
 # Checks that flow controllers are responding?
 +1 Validate GasDeck_PI;
}

State GasDeck_Low_Pressure {
 # Most likely we're here because the gas bottle is running low on gas. At that point we probably want to stop doing cals and leave enough to fill the cell at the end of the flight. 
  +1 Validate GasDeck_Close;
}

State GasDeck_FC_Not_Regulating {}

State GasDeck_Fill_Cell {
  > Command Exhaust_Vlv Off
  > Command Gas_Vlv_D On 
  > Air Flow SetPoint 10000 sccm
 Hold Until ( convert(Cel2P) > convert(GD_SetP) - 200 ) or 1:00;
  > Air Flow SetPoint 5000 sccm
 Hold Until ( convert(Cel2P) > convert(GD_SetP) - 100 ) or 1:00;
  > Air Flow SetPoint 1000 sccm
 Hold Until ( convert(Cel2P) > convert(GD_SetP) ) or 30;
  Validate GasDeck_Close;
}

State GasDeck_Pump_Purge {
      > Air Flow Setpoint 5000 sccm
+1:00 > Air Flow Setpoint 1000 sccm
+1:00 > Air Flow Setpoint 5000 sccm
+1:00 > Air Flow Setpoint 1000 sccm
+1:00 Validate GasDeck_Pump_Purge;
}

#---------------------------------------------------------------
# Partition 9: Realtime File Input
#---------------------------------------------------------------
Partition

State ReadFile_idle {}

State ReadFile "HTW.tmas" {
  +5 Validate ReadFile_idle;
}

#---------------------------------------------------------------
# Partition 10: ReadFile Conditions
#---------------------------------------------------------------
# Summary:
#   RFCond_Idle: Nothing
#   RFCond_TimeWarp: Wait for Time Warp
#---------------------------------------------------------------
Partition

State RFCond_Idle {}

State RFCond_TimeWarp {
  Hold until ( SW_St == SWS_TIMEWARP );
  Resume ReadFile;
  Validate RFCond_Idle;
}

#---------------------------------------------------------------
# Partition 11: Analog Input Monitoring
#---------------------------------------------------------------
Partition

%{
  AI_T30K Last_PC__T = 0;
  static int PC__T_static_count = 0;
  static int PC__T_delta_count = 0;
  static int AI_Reset_count = 0;
  static int AI_Reset_limit = 0;
%}
State AI_Watch {
    { if ( PC__T == Last_PC__T ) {
	if ( ++PC__T_static_count >= 5 ) {
	  msg(2, "PC__T has not changed in 5 seconds");
	  PC__T_delta_count = 0;
	  Validate AI_Reset;
	}
      } else {
	Last_PC__T = PC__T;
	PC__T_static_count = 0;
	if ( ++PC__T_delta_count > 5 ) {
	  PC__T_delta_count = 0;
	  AI_Reset_count = 0;
	}
      }
    }
}

State AI_Reset {
      > AI Reset
  +1  > AI Double Convert Row Zero
      { if ( AI_Reset_limit > 0 &&
	     ++AI_Reset_count >= AI_Reset_limit ) {
	  msg(2,"AI Max Reset Count Reached");
	  Validate AI_Fail;
	}
      }
      Hold until ( PC__T != Last_PC__T ) OR 5
      else Validate AI_Reset;
      Validate AI_Watch;
}

State AI_Fail {}

#--------------------------------------------------------------
# Partition 12: Lab Calibration
#--------------------------------------------------------------
Partition

State Calibrate_Init {}

State Calibrate_Start {
  Validate GasDeck_PI_Init;
  Hold Until ( convert(CellP) == convert(GD_SetP) ) or 30;
  +1 > Command Bub_In_Vlv_D On
  +1 > Command Bub_Out_Vlv_D On
  +4:00 > Bubbler Flow SetPoint 5 sccm
  +4:00 > Bubbler Flow SetPoint 10 sccm
  +4:00 > Bubbler Flow SetPoint 15 sccm
  +4:00 > Bubbler Flow SetPoint 20 sccm
  +4:00 > Bubbler Flow SetPoint 30 sccm
  +4:00 > Bubbler Flow SetPoint 40 sccm
  +4:00 > Bubbler Flow SetPoint 50 sccm
  +4:00 > Bubbler Flow SetPoint 40 sccm
  +4:00 > Bubbler Flow SetPoint 30 sccm
  +4:00 > Bubbler Flow SetPoint 20 sccm
  +4:00 > Bubbler Flow SetPoint 15 sccm
  +4:00 > Bubbler Flow SetPoint 10 sccm
  +4:00 > Bubbler Flow SetPoint 5 sccm
  +4:00 > Bubbler Flow SetPoint 0 sccm
  +4:00 > Bubbler Flow SetPoint 10 sccm
  +25:00 > Bubbler Flow SetPoint 0 sccm
  +1    Validate Calibrate_Stop;
}

State Calibrate_Stop {
     Validate GasDeck_Close;
  +1 Validate Calibrate_Idle;
}

State Calibrate_Idle {}

