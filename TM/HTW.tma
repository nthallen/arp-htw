#===============================================================
# ER-2 Flights, May-June 2021; Palmdale, CA, DCOTSS Mission
# Flight HTW.tma.
#===============================================================

#---------------------------------------------------------------
# Partition 1: Main Line Code
#---------------------------------------------------------------

### Need to verify switches before we use them
# Switches - 1100: Algo., 1111: No Algo. (Use runfile.1100 for flight)
# For Flight, 2 Switches in the Off (Zero) Position.
# If either switch in On (1, raised), most algo processing is suspended.
# If both switches are On (1, raised) Shutdown begins immediately.

%{
  #include "msg.h"
  #include "SWData.h"
%}

# INITIALIZE
State Init {
       > Telemetry Start
  +1   > Fail Light Off
  +1   > AI Double Convert Row Zero
  +10  Validate Throttle_Valve_Init;
  +15  Validate Standby;
}

# WAIT 
State Standby {
        depending on (OFF_GROUND) { Validate Record; }
        depending on (IN_AIR) { Validate Record; }
        depending on (AI_Fail) { Validate Shutdown; }
}

# RECORD  
State Record {
        depending on (ON_GROUND) { Validate Shutdown; }
        depending on (AI_Fail)   { Validate Shutdown; }
        "In Record";
}

# SHUTDOWN
State Shutdown {
      Hold until valid (Ops_Is_Shutdown) or 20;
 +5   > Fail Light On
      > quit
}

#---------------------------------------------------------------
# Partition 2: Altitude
#---------------------------------------------------------------
Partition

# This partition converts pressure (altitude) into states 
# (ON_GROUND, OFF_GROUND, IN_AIR). \
# The threshold pressures each have two values - one for 
# the flight up and the other for the flight down.
# This provides hysteresis and prevents bouncing.  
# We are effectively using two switches: 
# 	ON_GROUND and IN_AIR (BELOW CLOUDS = ABOVE CLOUDS)
# REF: 650 torr ~5000 ft
# Palmdale, CA is at elevation 2657'
# Salina, KS is at elevation 1227'

%{ /* Altitude definitions */
    double P_ground_up = 525.;
    double P_ground_dn = 575.;
    double P_clouds_up = 280.;
    double P_clouds_dn = 370.;
    int using_swp = 0;
%}

State ON_GROUND {
  { using_swp = 0; }
  { if (using_swp || (DACS_P > 0 && DACS_P < P_ground_up))
      Validate OFF_GROUND;
  }
}

State OFF_GROUND {
  { if ((using_swp == 2) || (!using_swp && DACS_P > 0 && DACS_P < P_clouds_up)) {
      Validate IN_AIR;
    } else if ((using_swp == 4) || (!using_swp && DACS_P > P_ground_dn)) {
      Validate ON_GROUND;
    }
  }
}

State IN_AIR {
  { if ( (using_swp == 3) || (!using_swp && DACS_P > P_clouds_dn))
      Validate OFF_GROUND;
  }
}

#---------------------------------------------------------------
# Partition 4: Operations
#---------------------------------------------------------------
Partition

%{
  int Ops_Ready_To_Calibrate;
%}

State Ops_Init {
      > Laser TEC Live SetPoints Enable
      Depending on (Shutdown) { Validate Ops_Shutdown; }
      Depending on (Record) { Validate Ops_Start; }
}

State Ops_Start {
      Depending on (Shutdown) { Validate Ops_Shutdown; }
   +5 Hold until valid (Pump_Watch);
   +1 > Laser TEC Setpoint 7.6 C
   +1 > Laser TEC Enable
  +30 Validate Ops_Sample;
}

State Ops_Sample {
       Depending on (Shutdown) { Validate Ops_Shutdown; }
#      { if (!Pump_On) Validate Ops_Fill_To_Ambient; }
    +1 Validate QCL_SelectRingandRun;
   +30 Validate QCL_SelectICOSandRun;
}

# State Ops_Calibrate {
#      Depending on (Shutdown) { Validate Ops_Shutdown; }
#      { if (!Pump_On) Validate Ops_Fill_To_Ambient; }
# }

State Ops_Shutdown {
 #   > Pressure Reg Off
  +1 Hold until valid (QCL_Is_Shutdown);
     > Set Cell Pressure Setpoint 700
     Validate Flow_Shutdown;
     Hold until valid (F_Shutdown);
     Validate Ops_Is_Shutdown;
}

State Ops_Is_Shutdown {}

#---------------------------------------------------------------
# Partition 5: Laser Control JPL 53
#---------------------------------------------------------------
Partition

%{
  int num_QCL_recovers = 0;
  #define LOW_CURRENT 0.02
  #define QCL_TEMP_LIMIT 20
  #define QCL_TEMP_PREC 1.0
  #define QCL_TEMP_OK(x,y) \
  (x < QCL_TEMP_LIMIT && x > y-QCL_TEMP_PREC && x < y+QCL_TEMP_PREC)
  #define LPV_TEMP_OK(x,y) (x < (y+1))
%}
# Mini Starting and Stopping

State QCL_Init {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
  +1  > SSP Stop
  +1  Validate QCLI_Stop;
      Hold until valid (QCLI_Idle);
      Validate QCL_Idle;
}

State QCL_Idle {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
    Validate QCLI_Idle;
}

State QCL_Start {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
    Hold until ( SSP_Status == SSP_STATUS_READY )
    or 2 else {
      nl_error( 2, "SSP Not Ready in QCL_Start" );
      Validate QCL_SSP_Recover;
    }
    Hold until ( QCL_TEMP_OK(convert(LTE_T),convert(LTE_Set_T)) ) or 20
    else Validate QCL_Out_TSpec;
    Hold until valid (QCLI_Idle) or 2
    else Validate QCLI_Stop;
    Hold until valid (QCLI_Idle);
 +1 > SSP Start
    Hold until ( SSP_Status == SSP_STATUS_ARMED )
    or 20 else {
      nl_error( 2, "Not Armed in QCL_Start" );
      Validate QCL_SSP_Recover;
    }
    Validate QCLI_Run;
    Hold until (SSP_Status == SSP_STATUS_TRIG &&
                convert(Las_I) > LOW_CURRENT) or 20
    else Validate QCL_SSP_Recover;
    { num_QCL_recovers = 0; }
    Validate QCL_Watch;
}

# QCL_NC_1: stop SSP, set NCoadd to 1 and restart SSP
# without shutting down QCLI
State QCL_NC_1 {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
   +1 > SSP Stop
      Hold until (SSP_Status == SSP_STATUS_READY) or 2 else {
        nl_error( 2, "SSP Not Ready in QCL_NC_1" );
        Validate QCL_SSP_Recover;
      }
   +1 > SSP Set NCoadd 1
      > SSP Start
      Hold until (SSP_Status == SSP_STATUS_ARMED ||
                  SSP_Status == SSP_STATUS_TRIG) or 20 else {
        nl_error(2, "Not starting in QCL_NC_1");
        Validate QCL_SSP_Recover;
      }
   +1 Validate QCL_Watch;
}

State QCL_Watch NoLog {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
    { if ( SSP_Status == SSP_STATUS_READY ) {
        nl_error( 2, "SSP Went Ready Spontaneously" );
        Validate QCL_SSP_Recover;
      }
    }
    hold until ( SSP_Status != SSP_STATUS_TRIG ||
         !QCL_TEMP_OK(convert(LTE_T),convert(LTE_Set_T)) ||
         convert(Las_I) <= LOW_CURRENT );
    hold until ( SSP_Status == SSP_STATUS_TRIG &&
         QCL_TEMP_OK(convert(LTE_T),convert(LTE_Set_T)) &&
         convert(Las_I) >= LOW_CURRENT) or 2
    else Validate QCL_Watch_Recover;
    Validate QCL_Watch;
}

State QCL_Watch_Recover NoLog {
  { if (!QCL_TEMP_OK(convert(LTE_T),convert(LTE_Set_T)))
      Validate QCL_Out_TSpec;
    else if (convert(Las_I) <= LOW_CURRENT)
      Validate QCL_Out_Spec;
    else if (SSP_Status != SSP_STATUS_TRIG)
      Validate QCL_SSP_Recover;
    else Validate QCL_Watch;
  }
}

State QCL_SSP_Recover NoLog {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
    > SSP Stop
    { if ( ++num_QCL_recovers > 20 ) {
        nl_error( 2, "Exceeded num_QCL_recovers. Trying reset" );
        num_QCL_recovers = 0;
        Validate QCLI_Stop_Reset;
      }
    }
    Hold until ( SSP_Status == SSP_STATUS_READY ) or 10
    else Validate QCL_SSP_Not_Talking;
 +2 Validate QCLI_Stop;
    Hold until valid (QCLI_Idle);
    Validate QCL_Start;
}

State QCL_SSP_Not_Talking {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
    > SSP Stop
    { if ( ++num_QCL_recovers > 20 ) Validate QCL_Fail; }
    Hold until ( SSP_Status == SSP_STATUS_READY ) or 10
    else Validate QCL_SSP_Not_Talking;
    Validate QCL_SSP_Recover;
}

State QCL_Fail {
    > Log Laser Has Failed
    > SSP Stop
    Validate QCLI_Stop;
    > Laser TEC Disable
    depending on (Shutdown) { Validate QCL_Is_Shutdown; }
}

State QCL_Shutdown {
    > SSP Stop
 +1 Validate QCLI_Stop;
    Hold until valid (QCLI_Idle) or 20;
    > Log Laser Has Shutdown
    > Laser TEC Disable
    Validate QCL_Is_Shutdown;
}

State QCL_Is_Shutdown {}

State QCL_Out_Spec {
    Validate QCLI_Stop;
    Hold until Valid (QCLI_Idle);
    Validate QCL_Start;
}

State QCL_Out_TSpec {
    Validate QCLI_Stop;
 +1 > Laser TEC Enable
    Hold until valid (QCLI_Idle);
    Hold until ( QCL_TEMP_OK(convert(LTE_T),convert(LTE_Set_T)) &&
                 LPV_TEMP_OK(convert(LPV_T),convert(LPV_Set_T)) );
 +10 Validate QCL_Start;
}

State QCL_Stop {
    Depending on (Shutdown) { Validate QCL_Shutdown; }
    > SSP Stop
 +1 Validate QCLI_Stop;
    Hold until valid (QCLI_Idle);
    Validate QCL_Idle;
}

#Running Waveforms

State QCL_SelectICOSandRun {
      Depending on (Shutdown) { Validate QCL_Shutdown; }
      > SSP Stop
      Hold until ( SSP_Status == SSP_STATUS_READY ) or 5
      else { nl_error( 2, "Not Ready in QCL_SelectICOSandRun" ); }
      Hold until valid (QCLI_Idle) or 2
      else Validate QCLI_Stop;
      Hold until valid (QCLI_Idle);
   +1 > Laser TEC Setpoint 7.6 C
   +1 > Laser TEC Enable
      Hold until ( QCL_TEMP_OK(convert(LTE_T),convert(LTE_Set_T)) );
  +10 > Select QCLI Waveform JPL53_400Hz
   +3 Validate QCL_Start;
}

State QCL_SelectRingandRun {
      Depending on (Shutdown) { Validate QCL_Shutdown; }
      > SSP Stop
      Hold until ( SSP_Status == SSP_STATUS_READY ) or 5
      else { nl_error( 2, "Not Ready in QCL_SelectRingandRun" ); }
      Hold until valid (QCLI_Idle) or 2
      else Validate QCLI_Stop;
      Hold until valid (QCLI_Idle);
   +1 > Laser TEC Setpoint 7.8 C
   +1 > Laser TEC Enable
      Hold until ( QCL_TEMP_OK(convert(LTE_T),convert(LTE_Set_T)) );
  +10 > Select QCLI Waveform RingRamp
#  +1 > SSP Set NSample 3500
   +2 Validate QCL_Start;
}

#---------------------------------------------------------------
# Partition 6: QCLI Control
#---------------------------------------------------------------
Partition

%{
  int num_QCLI_recovers = 0;
%}

State QCLI_Idle {}

State QCLI_Run {
    Hold until ( (QCLI_s & 0x3938) == 0 ) or 2
    else > QCLI clear errors
    Hold until ( (QCLI_s & 0x3938) == 0 ) or 2
    else Validate QCLI_Start_Reset;
    > QCLI Run
    { num_QCLI_recovers = 0;
      Validate QCLI_Running;
    }
}

State QCLI_Running {
}

State QCLI_Start_Reset {
    { if ( ++num_QCLI_recovers > 20 ) {
        nl_error( 2,"Exceeded num_QCLI_recovers in QCLI_Start_Reset" );
        Validate QCLI_Fail;
      }
    }
    > Command QCLI_Reset On
 +1 > Command QCLI_Reset Off
    Validate QCLI_Run;
}

State QCLI_Stop {
      > QCLI Stop
      Hold until ( (QCLI_s & 0x3938) == 0 ) or 2
      else > QCLI clear errors
      Hold until ( (QCLI_s & 0x3938) == 0 ) or 2
      else Validate QCLI_Stop_Reset;
      Validate QCLI_Idle;
}

State QCLI_Stop_Reset {
    { if ( ++num_QCLI_recovers > 20 ) {
        nl_error( 2,"Exceeded num_QCLI_recovers in QCLI_Stop_Reset" );
        Validate QCLI_Fail;
      }
    }
    > Command QCLI_Reset On
 +1 > Command QCLI_Reset Off
    Hold until ( (QCLI_s & 0x3938) == 0 ) or 2
    else > QCLI clear errors
    Hold until ( (QCLI_s & 0x3938) == 0 ) or 2
    else Validate QCLI_Stop_Reset;
    { num_QCLI_recovers = 0;
      ci_sendfcmd( 0, "Select QCLI Waveform Number %d\n", QCLI_Wave );
      Validate QCLI_Idle;
    }
}

State QCLI_Fail {
    { nl_error( 2, "QCLI Not Responding" ); }
 +2:00 Validate QCLI_Stop_Reset;
}

State QCLI_Shutdown {}

#---------------------------------------------------------------
# Partition 7: Pumpkin Troll
# Needs to be written!
#---------------------------------------------------------------
Partition
State Pump_Watch NoLog {
  { if ( convert(PumpT) > 75 || convert(PMotT) > 75 ) {
      msg(2, "Pump over temp: PumpT %.1lf C PMotT %.1lf C",
            convert(PumpT), convert(PMotT));
      Validate Pump_Over_Temp;
    }
  }
}

State Pump_Over_Temp NoLog {
  Hold until ( convert(PumpT) < 60 && convert(PMotT) < 60 );
  Hold until ( convert(PumpT) > 75 || convert(PMotT) > 75 ) or 15
  else Validate Pump_Over_Temp;
  Validate Pump_Watch;
}

#---------------------------------------------------------------
# Partition 9: Realtime File Input
#---------------------------------------------------------------
Partition

State ReadFile_idle {}

State ReadFile "HTW.tmas" {
  +5 Validate ReadFile_idle;
}

#---------------------------------------------------------------
# Partition 10: ReadFile Conditions
#---------------------------------------------------------------
# Summary:
#   RFCond_Idle: Nothing
#   RFCond_TimeWarp: Wait for Time Warp
#---------------------------------------------------------------
Partition

State RFCond_Idle {}

State RFCond_TimeWarp {
  Hold until ( SW_St == SWS_TIMEWARP );
  Resume ReadFile;
  Validate RFCond_Idle;
}

#---------------------------------------------------------------
# Partition 11: Analog Input Monitoring
#---------------------------------------------------------------
Partition

%{
  AI_T30K Last_PC__T = 0;
  static int PC__T_static_count = 0;
  static int PC__T_delta_count = 0;
  static int AI_Reset_count = 0;
  static int AI_Reset_limit = 0;
%}
State AI_Watch {
    { if ( PC__T == Last_PC__T ) {
	if ( ++PC__T_static_count >= 5 ) {
	  msg(2, "PC__T has not changed in 5 seconds");
	  PC__T_delta_count = 0;
	  Validate AI_Reset;
	}
      } else {
	Last_PC__T = PC__T;
	PC__T_static_count = 0;
	if ( ++PC__T_delta_count > 5 ) {
	  PC__T_delta_count = 0;
	  AI_Reset_count = 0;
	}
      }
    }
}

State AI_Reset {
      > AI Reset
  +1  > AI Double Convert Row Zero
      { if ( AI_Reset_limit > 0 &&
	     ++AI_Reset_count >= AI_Reset_limit ) {
	  msg(2,"AI Max Reset Count Reached");
	  Validate AI_Fail;
	}
      }
      Hold until ( PC__T != Last_PC__T ) OR 5
      else Validate AI_Reset;
      Validate AI_Watch;
}

State AI_Fail {}

#--------------------------------------------------------------
# Partition 12: Lab Calibration
#--------------------------------------------------------------
Partition

State Calibrate_Init {}

State Calibrate_Start {
  Validate GasDeck_PI_Init;
  Hold Until ( convert(CellP) == convert(GD_SetP) ) or 30;
  +1 > Command Bub_In_Vlv_D On
  +1 > Command Bub_Out_Vlv_D On
  +4:00 > Bubbler Flow SetPoint 5 sccm
  +4:00 > Bubbler Flow SetPoint 10 sccm
  +4:00 > Bubbler Flow SetPoint 15 sccm
  +4:00 > Bubbler Flow SetPoint 20 sccm
  +4:00 > Bubbler Flow SetPoint 30 sccm
  +4:00 > Bubbler Flow SetPoint 40 sccm
  +4:00 > Bubbler Flow SetPoint 50 sccm
  +4:00 > Bubbler Flow SetPoint 40 sccm
  +4:00 > Bubbler Flow SetPoint 30 sccm
  +4:00 > Bubbler Flow SetPoint 20 sccm
  +4:00 > Bubbler Flow SetPoint 15 sccm
  +4:00 > Bubbler Flow SetPoint 10 sccm
  +4:00 > Bubbler Flow SetPoint 5 sccm
  +4:00 > Bubbler Flow SetPoint 0 sccm
  +4:00 > Bubbler Flow SetPoint 10 sccm
  +25:00 > Bubbler Flow SetPoint 0 sccm
  +1    Validate Calibrate_Stop;
}

State Calibrate_Stop {
     Validate GasDeck_Close;
  +1 Validate Calibrate_Idle;
}

State Calibrate_Idle {}

